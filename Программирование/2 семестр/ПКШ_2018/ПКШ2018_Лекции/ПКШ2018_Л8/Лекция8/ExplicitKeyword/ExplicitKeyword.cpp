 /*Измененный вариант конструктора класса Two из 
 предыдущего примера выглядит так:
 */
 //L8:ExplicitKeyword.срр 
 
 class One {
 public: One() {} 
 };
class Two {
 public: 
	 explicit 
		 Two(const One&) {} 
};
void f(Two) {}
int main() { 
	One one; 
//	f(one);// Автоматическое приведение типа запрещено 
	f(Two(one)); //Можно - приведение типа выполняется пользователем
} 
/*Определяя конструктор Two с ключевым словом explicit, мы запрещаем
компилятору выполнять какие-либо операции по автоматическому 
приведению типа с использованием этого конкретного конструктора 
(другие конструкторы класса, у которых слово explicit отсутствует, 
по-прежнему могут задействоваться для автоматических преобразований).
Если пользователь хочет выполнить приведение типа, он должен явно 
указать на это обстоятельство в программе. В рассмотренном фрагменте
вызов f(Two(one)) создает временный объект типа Two из объекта one, 
как это делал компилятор в предыдущей версии.
*/
